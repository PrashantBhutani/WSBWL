.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Yahoo::Search::Response 3pm"
.TH Yahoo::Search::Response 3pm "2010-06-15" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.SH "VERSION"
.IX Header "VERSION"
version 1.11.3
Yahoo::Search::Response \*(-- Container object for the result set of one query
to the Yahoo! Search \s-1API\s0.
(This package is included in, and automatically loaded by, the Yahoo::Search package.)
.SH "Package Use"
.IX Header "Package Use"
You never need to \f(CW\*(C`use\*(C'\fR this package directly \*(-- it is loaded
automatically by Yahoo::Search.
.SH "Object Creation"
.IX Header "Object Creation"
\&\f(CW\*(C`Response\*(C'\fR objects are created by the \f(CW\*(C`Fetch()\*(C'\fR method of a \f(CW\*(C`Request\*(C'\fR
(Yahoo::Search::Request) object, e.g. by
.PP
.Vb 1
\&  my $Response = Yahoo::Search\->new(...)\->Request()\->Fetch();
.Ve
.PP
or by shortcuts to the same, such as:
.PP
.Vb 1
\&  my $Response = Yahoo::Search\->Query(...);
.Ve
.SH "Methods"
.IX Header "Methods"
A \f(CW\*(C`Response\*(C'\fR object has the following methods:
.ie n .IP "$Response\->\fICount()\fR" 4
.el .IP "\f(CW$Response\fR\->\fICount()\fR" 4
.IX Item "$Response->Count()"
Returns the number of \f(CW\*(C`Result\*(C'\fR objects available in this \f(CW\*(C`Response\*(C'\fR. See
Yahoo::Search::Result for details on \f(CW\*(C`Result\*(C'\fR objects.
.ie n .IP "$Response\->FirstOrdinal([ \fIseparator\fR ])" 4
.el .IP "\f(CW$Response\fR\->FirstOrdinal([ \fIseparator\fR ])" 4
.IX Item "$Response->FirstOrdinal([ separator ])"
Returns the index of the first \f(CW\*(C`Result\*(C'\fR object (e.g. the \*(L"30\*(R" of \fIresults
30 through 40 out of 5,329\fR). This is the same as the \f(CW\*(C`Start\*(C'\fR arg of the
\&\f(CW\*(C`Request\*(C'\fR that generated this \f(CW\*(C`Response\*(C'\fR.
.Sp
If an optional argument is given and is true, it is used as a separator
every three digits. In the \s-1US\s0, one would use
.Sp
.Vb 1
\&   $Response\->FirstOrdinal(\*(Aq,\*(Aq)
.Ve
.Sp
to return, say, \*(L"1,230\*(R" instead of the \*(L"1230\*(R" that
.Sp
.Vb 1
\&   $Response\->FirstOrdinal()
.Ve
.Sp
might return.
.ie n .IP "$Response\->CountAvail([ \fIseparator\fR ])" 4
.el .IP "\f(CW$Response\fR\->CountAvail([ \fIseparator\fR ])" 4
.IX Item "$Response->CountAvail([ separator ])"
Returns an approximate number of total search results available, were you
to ask for them all (e.g. the \*(L"5329\*(R" of the \fIresults 30 through 40 out of
5329\fR).
.Sp
If an optional argument is given and is true, it is used as a separator
every three digits. In the \s-1US\s0, one would use
.Sp
.Vb 1
\&   $Response\->CountAvail(\*(Aq,\*(Aq)
.Ve
.Sp
to return, say, \*(L"5,329\*(R" instead of the \*(L"5329\*(R" that
.Sp
.Vb 1
\&   $Response\->CountAvail()
.Ve
.Sp
might return.
.ie n .IP "$Response\->\fILinks()\fR" 4
.el .IP "\f(CW$Response\fR\->\fILinks()\fR" 4
.IX Item "$Response->Links()"
Returns a list of links from the response (one link per result):
.Sp
.Vb 7
\&  use Yahoo::Search;
\&  if (my $Response = Yahoo::Search\->Query(Doc => \*(AqBritney\*(Aq))
\&  {
\&      for my $link ($Response\->Links) {
\&          print "<br>$link\en";
\&      }
\&  }
.Ve
.Sp
This prints one
.Sp
.Vb 1
\&  <br><a href="...">title of the link</a>
.Ve
.Sp
line per result returned from the query.
.Sp
(\fINot appropriate for \f(BISpell\fI and \f(BIRelated\fI search results\fR)
.ie n .IP "$Response\->\fITerms()\fR" 4
.el .IP "\f(CW$Response\fR\->\fITerms()\fR" 4
.IX Item "$Response->Terms()"
(\fIAppropriate for \f(BISpell\fI and \f(BIRelated\fI search results\fR)
.Sp
Returns a list of text terms.
.ie n .IP "$Response\->\fIResults()\fR" 4
.el .IP "\f(CW$Response\fR\->\fIResults()\fR" 4
.IX Item "$Response->Results()"
Returns a list of Yahoo::Search::Result \f(CW\*(C`Result\*(C'\fR objects representing
all the results held in this \f(CW\*(C`Response\*(C'\fR. For example:
.Sp
.Vb 7
\&  use Yahoo::Search;
\&  if (my $Response = Yahoo::Search\->Query(Doc => \*(AqBritney\*(Aq))
\&  {
\&      for my $Result ($Response\->Results) {
\&         printf "%d: %s\en", $Result\->I, $Result\->Url;
\&      }
\&  }
.Ve
.Sp
This is not valid for \fISpell\fR and \fIRelated\fR searches.
.ie n .IP "$Response\->NextResult(options)" 4
.el .IP "\f(CW$Response\fR\->NextResult(options)" 4
.IX Item "$Response->NextResult(options)"
Returns a \f(CW\*(C`Result\*(C'\fR object, or nothing. (On error, returns nothing and sets
\&\f(CW$@\fR.)
.Sp
The first time \f(CW\*(C`NextResult\*(C'\fR is called for a given \f(CW\*(C`Response\*(C'\fR object, it
returns the \f(CW\*(C`Result\*(C'\fR object for the first result in the set. Returns
subsequent \f(CW\*(C`Result\*(C'\fR objects for subsequent calls, until there are none
left, at which point what is returned depends upon whether the
auto-continuation feature is turned on (more on that in a moment).
.Sp
The following produces the same results as the \f(CW\*(C`Results()\*(C'\fR example above:
.Sp
.Vb 6
\& use Yahoo::Search;
\& if (my $Response = Yahoo::Search\->Query(Doc => \*(AqBritney\*(Aq)) {
\&     while (my $Result = $Response\->NextResult) {
\&         printf "%d: %s\en", $Result\->I, $Result\->Url;
\&     }
\& }
.Ve
.Sp
\&\fBAuto-Continuation\fR
.Sp
If auto-continuation is turned on, then upon reaching the end of the result
set, \f(CW\*(C`NextResult\*(C'\fR automatically fetches the next set of results and
returns \fIits\fR first result.
.Sp
This can be convenient, but \fBcan be very dangerous\fR, as it means that a
loop which calls \f(CW\*(C`NextResult\*(C'\fR, unless otherwise exited, will fetch results
from Yahoo! until there are no more results for the query, or until you
have exhausted your access limits.
.Sp
Auto-continuation can be turned on in several ways:
.RS 4
.IP "\(bu" 3
On a per \f(CW\*(C`NextResult\*(C'\fR basis by calling as
.Sp
.Vb 1
\& $Response\->NextResult(AutoContinue => 1)
.Ve
.Sp
as with this example
.Sp
.Vb 9
\& use Yahoo::Search;
\& ##
\& ## WARNING:   DANGEROUS DANGEROUS DANGEROUS
\& ##
\& if (my $Response = Yahoo::Search\->Query(Doc => \*(AqBritney\*(Aq)) {
\&     while (my $Result = $Response\->NextResult(AutoContinue => 1)) {
\&         printf "%d: %s\en", $Result\->I, $Result\->Url;
\&     }
\& }
.Ve
.IP "\(bu" 3
By using
.Sp
.Vb 1
\&  AutoContinue => 1
.Ve
.Sp
when creating the request (e.g. in a Yahoo::Search\->Query call), as
with this example:
.Sp
.Vb 11
\& use Yahoo::Search;
\& ##
\& ## WARNING:   DANGEROUS DANGEROUS DANGEROUS
\& ##
\& if (my $Response = Yahoo::Search\->Query(Doc => \*(AqBritney\*(Aq,
\&                                              AutoContinue => 1))
\& {
\&     while (my $Result = $Response\->NextResult) {
\&        printf "%d: %s\en", $Result\->I, $Result\->Url;
\&     }
\& }
.Ve
.IP "\(bu" 3
By creating a query via a search-engine object created with
.Sp
.Vb 1
\&  AutoContinue => 1
.Ve
.Sp
as with this example:
.Sp
.Vb 5
\& use Yahoo::Search;
\& ##
\& ## WARNING:   DANGEROUS DANGEROUS DANGEROUS
\& ##
\& my $SearchEngine = Yahoo::Search\->new(AutoContinue => 1);
\&
\& if (my $Response = $SearchEngine\->Query(Doc => \*(AqBritney\*(Aq)) {
\&     while (my $Result = $Response\->NextResult) {
\&        printf "%d: %s\en", $Result\->I, $Result\->Url;
\&     }
\& }
.Ve
.IP "\(bu" 3
By creating a query when Yahoo::Search had been loaded via:
.Sp
.Vb 1
\& use Yahoo::Search AutoContinue => 1;
.Ve
.Sp
as with this example:
.Sp
.Vb 9
\& use Yahoo::Search AutoContinue => 1;
\& ##
\& ## WARNING:   DANGEROUS DANGEROUS DANGEROUS
\& ##
\& if (my $Response = Yahoo::Search\->Query(Doc => \*(AqBritney\*(Aq)) {
\&     while (my $Result = $Response\->NextResult) {
\&         printf "%d: %s\en", $Result\->I, $Result\->Url;
\&     }
\& }
.Ve
.RE
.RS 4
.Sp
All these examples are dangerous because they loop through results,
fetching more and more, until either all results that Yahoo! has for the
query at hand have been fetched, or the Yahoo! Search server access limits
have been reached and further access is denied. So, be sure to rate-limit
the accesses, or explicitly break out of the loop at some appropriate
point.
.RE
.ie n .IP "$Response\->\fIReset()\fR" 4
.el .IP "\f(CW$Response\fR\->\fIReset()\fR" 4
.IX Item "$Response->Reset()"
Rests the iterator so that the next \f(CW\*(C`NextResult\*(C'\fR returns the first of the
\&\f(CW\*(C`Response\*(C'\fR object's \f(CW\*(C`Result\*(C'\fR objects.
.ie n .IP "$Response\->\fIRequest()\fR" 4
.el .IP "\f(CW$Response\fR\->\fIRequest()\fR" 4
.IX Item "$Response->Request()"
Returns the \f(CW\*(C`Request\*(C'\fR object from which this \f(CW\*(C`Response\*(C'\fR object was
derived.
.ie n .IP "$Response\->\fINextRequest()\fR" 4
.el .IP "\f(CW$Response\fR\->\fINextRequest()\fR" 4
.IX Item "$Response->NextRequest()"
Returns a \f(CW\*(C`Request\*(C'\fR object which will fetch the subsequent set of results
(e.g. if the current \f(CW\*(C`Response\*(C'\fR object represents the first 10 query
results, \f(CW\*(C`NextRequest()\*(C'\fR returns a \f(CW\*(C`Request\*(C'\fR object that represents a
query for the \fInext\fR 10 results.)
.Sp
Returns nothing if there were no results in the current \f(CW\*(C`Response\*(C'\fR object
(thereby eliminating the possibility of there being a \fInext\fR result set).
On error, sets \f(CW$@\fR and returns nothing.
.ie n .IP "$Response\->\fINextResponse()\fR" 4
.el .IP "\f(CW$Response\fR\->\fINextResponse()\fR" 4
.IX Item "$Response->NextResponse()"
Like \f(CW\*(C`NextRequest\*(C'\fR, but goes ahead and calls the \f(CW\*(C`Request\*(C'\fR object's
\&\f(CW\*(C`Fetch\*(C'\fR method to return the \f(CW\*(C`Result\*(C'\fR object for the next set of results.
.ie n .IP "$Response\->\fIUri()\fR" 4
.el .IP "\f(CW$Response\fR\->\fIUri()\fR" 4
.IX Item "$Response->Uri()"
Returns the \f(CW\*(C`URI::http\*(C'\fR object that was fetched to create this response.
It is the same as:
.Sp
.Vb 1
\&  $Response\->Request\->Uri()
.Ve
.ie n .IP "$Response\->\fIUrl()\fR" 4
.el .IP "\f(CW$Response\fR\->\fIUrl()\fR" 4
.IX Item "$Response->Url()"
Returns the url that was fetched to create this response.
It is the same as:
.Sp
.Vb 1
\&  $Response\->Request\->Url()
.Ve
.ie n .IP "$Response\->\fIRawXml()\fR" 4
.el .IP "\f(CW$Response\fR\->\fIRawXml()\fR" 4
.IX Item "$Response->RawXml()"
Returns a string holding the raw xml returned from the Yahoo! Search
servers.
.ie n .IP "$Response\->\fIMapUrl()\fR" 4
.el .IP "\f(CW$Response\fR\->\fIMapUrl()\fR" 4
.IX Item "$Response->MapUrl()"
Valid only for a \fILocal\fR search, returns a url to a map showing all
results. (This is the same as each \f(CW\*(C`Result\*(C'\fR object's \f(CW\*(C`AllMapUrl\*(C'\fR method.)
.ie n .IP "$Response\->RelatedRequest" 4
.el .IP "\f(CW$Response\fR\->RelatedRequest" 4
.IX Item "$Response->RelatedRequest"
.PD 0
.ie n .IP "$Response\->RelatedResponse" 4
.el .IP "\f(CW$Response\fR\->RelatedResponse" 4
.IX Item "$Response->RelatedResponse"
.PD
Perform a \fIRelated\fR request for search terms related to the query phrase
of the current request, returning the new \f(CW\*(C`Request\*(C'\fR or \f(CW\*(C`Response\*(C'\fR object,
respectively.
.Sp
Both return nothing if the current request is already for a \fIRelated\fR
search.
.Sp
For example:
.Sp
.Vb 1
\&  print "Did you mean ", join(" or ", $Response\->RelatedResponse\->Terms()), "?";
.Ve
.ie n .IP "$Response\->SpellRequest" 4
.el .IP "\f(CW$Response\fR\->SpellRequest" 4
.IX Item "$Response->SpellRequest"
.PD 0
.ie n .IP "$Response\->SpellResponse" 4
.el .IP "\f(CW$Response\fR\->SpellResponse" 4
.IX Item "$Response->SpellResponse"
.PD
Perform a \fISpell\fR request for a search term that may reflect proper
spelling of the query phrase of the current request, returning the new
\&\f(CW\*(C`Request\*(C'\fR or \f(CW\*(C`Response\*(C'\fR object, respectively.
.Sp
Both return nothing if the current request is already for a \fISpell\fR
search.
.SH "Author"
.IX Header "Author"
Jeffrey Friedl (jfriedl@yahoo.com)
